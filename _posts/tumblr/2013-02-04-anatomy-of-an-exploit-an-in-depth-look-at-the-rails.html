---
layout: post
title: 'Anatomy of an Exploit: An In-depth Look at the Rails YAML Vulnerability'
date: '2013-02-04T12:46:00-06:00'
tags:
permalink: /post/42283920969/anatomy-of-an-exploit-an-in-depth-look-at-the-rails
---

> This was originally posted to https://rubysource.com/anatomy-of-an-exploit-an-in-depth-look-at-the-rails-yaml-vulnerability/ however it is giving people "Potential Security Risk Ahead" warnings when visiting. This is a reproduciton of the original contents

<p>
    Exploits happen, and this month the Rails and Ruby communities have seen no shortage. From a major exploit in Rails to a slightly different Rubygems.org attack, there has never been a better time to brush up on software security.</p><p>Maybe you’re wondering why these vulnerabilities happen in the first place, why they weren’t caught in the first place, or maybe you just want to know the specifics of this attack. We’ll start off by taking a look at the anatomy of a security exploit, and then dive into the gory details of the YAML issue.</p><h2>Why Insecure Code Happens</h2><p>No one intends to write insecure software. These vulnerabilities are bugs in the software that can be taken advantage of by others. Unlike a normal bug that will cause your software to not function as intended, a bug that opens up a security hole might still work fine for your task and never actually throw any errors. Often times this is due to side effects in your code. Let’s take a look at some code examples:</p><h2>Unexpected Input</h2><p>Let’s say you need to double a number for some reason, so you write a function like this:</p><pre><code>def double(number)
  return number * 2
<p>Exploits happens, and this month the Rails and Ruby communities have seen no shortage. From a major exploit in Rails to a slightly different Rubygems.org attack, there has never been a better time to brush up on software security.</p>

<p>Maybe you’re wondering why these vulnerabilities happen in the first place, why they weren’t caught in the first place, or maybe you just want to know the specifics of this attack. We’ll start off by taking a look at the anatomy of a security exploit, and then dive into the gory details of the YAML issue.</p>

<h3><a href="https://rubysource.com/anatomy-of-an-exploit-an-in-depth-look-at-the-rails-yaml-vulnerability/">Continue Reading&#8230;</a></h3>
end
</code></pre><p>You test it out and it works fine:</p><pre><code>double(10)
# =&gt; 20
</code></pre><p>While this isn’t an insecure function, it can be used in ways you didn’t intend. Check out what happens when we pass a string to the function:</p><pre><code>double("foo")
# =&gt; "foofoo"
</code></pre><p>This isn’t what we wanted nor is it the original intention of the code. Regardless, it’s a side effect of our implementation, if you pass in a string the <code>*</code> operator will be called on it which duplicates the string.</p><p>This isn’t actually opening up any security holes, but it just goes to show you how software intended to do one thing can sometimes have unintended abilities.</p><h2>A Real Example</h2><p>We’re going to look at all the elements that enabled the YAML attack to happen on Rails system. You should know that all of this information is publicly available already and in the hands of the “bad guys” The hope is this info helps you to write better code and make better decisions in the future.</p><p>If you do discover a security vulnerability in a framework or platform, do the responsible thing and <a href="http://web.archive.org/web/20130210084912/http://rubyonrails.org/security">report it to the owners</a> before making the information public.</p><p>To understand the attack you need to understand YAML, let’s do a quick refresher.</p><h2>YAML Refresher</h2><p>YAML (<a href="http://web.archive.org/web/20130210084912/http://en.wikipedia.org/wiki/YAML">YAML Ain’t Markup Language</a>) is often used by Rubyists to store configuration files. The most famous yml file is probably the <code>config/database.yml</code> used in Rails and it looks like this:</p><pre><code>development:
  adapter: postgresql
  encoding: utf8
  database: example_development
  pool: 5
  host: localhost
</code></pre><p>And can be read in using <code>YAML::load_file</code></p><pre><code>require 'yaml'
database_config = YAML::load_file('database.yml')
puts database_config["development"]
# =&gt; {"adapter"=&gt;"postgresql", "encoding"=&gt;"utf8", "database"=&gt;"example_development", "pool"=&gt;5, "host"=&gt;"localhost"}
</code></pre><p>YAML isn’t just for files, it’s a serialization format like JSON. We can use it to pass complicated objects like strings, numbers, and arrays. There is even support to pass arbitrary user defined objects like <code>User</code> or <code>Product</code>. This is where we get into trouble.</p><h2>Ruby Objects in YAML</h2><p>YAML allows us to represent ruby objects directly, the best way to understand how it works is to see it in action. Let’s see how to build a simple Array. You could put this in the top of a <code>.yml</code> file and read it in:</p><pre><code>--- !ruby/array:Array
  - jacket
  - sweater
</code></pre><p>When you parse this it should produce <code>["jacket", "sweater"]</code>. But we’re not limited to simple Ruby objects like arrays and strings, we can build any class that is in our project like <code>User</code> if we want to:</p><pre><code>--- !ruby/hash:User
email: richard@example.com
</code></pre><p>Now when we load this YAML formatted string in:</p><pre><code>string = "--- !ruby/hash:User\n" +
"email: richard@example.com"
YAML::load(string)
 =&gt; #&lt;User id: 1, email: "richard@example.com"&gt;
</code></pre><p>We get a User object. Essentially what Ruby is doing is taking all the attributes on the left such as “email” and applying them as values on the right to a new object as if it was a hash. Like this:</p><pre><code>user = User.new
user["email"] = "richard@example.com"
</code></pre><p>This is desired functionality by the creators of YAML, since it gives developers the ability to write and read Ruby objects to disk, like an object database. Unfortunately, this is an often overlooked ability of YAML. Furthermore, this ability has an unintended side effect, much like being able to pass a string into our <code>double()</code> method.</p><h2>A Vulnerable Object</h2><p>You might be tempted to think that since we’re only creating objects that have to be defined on our servers, this object instantiation ability wouldn’t be too bad. Unfortunately, let’s see how attackers used these functions to be able to execute arbitrary code.</p><p>To take advantage of this exploit, we need a class in our code that evaluates code either on create:</p><pre><code>user = User.new
</code></pre><p>or when we’re setting values</p><pre><code>user["email"] = "richard@example.com"
</code></pre><p>Since both “email” and “richard@example.com” are values we can manipulate through YAML that is the best place to look.</p><p>In this case a vulnerable class <code>ActionDispatch::Routing::RouteSet::NamedRouteCollection</code> was found to be exploitable via <a href="http://web.archive.org/web/20130210084912/https://github.com/lian">@lian</a> and announced via <a href="http://web.archive.org/web/20130210084912/https://community.rapid7.com/community/metasploit/blog/2013/01/09/serialization-mischief-in-ruby-land-cve-2013-0156?x=1">Rapid7</a>. To understand how this class is exploitable, let’s try to run arbitrary code on the class directly.</p><p>First we instantiate the class:</p><pre><code>unsafe_object = ActionDispatch::Routing::RouteSet::NamedRouteCollection.new
</code></pre><p>Then make a value:</p><pre><code>struct        = OpenStruct.new(defaults: {})
</code></pre><p>Now, we craft an exploit payload <code>foo; eval(puts '=== hello there'.inspect);</code> and set the attribute of the payload equal to the value like this:</p><pre><code>unsafe_object["foo; eval(puts '=== hello there'.inspect);" ] = struct
</code></pre><p>Now when you run this code you will get an error, but before that error any code you put in that <code>eval()</code> will be executed:</p><pre><code># =&gt; "=== hello there"
</code></pre><p>This behavior isn’t inherently unsafe, after all we had to manually build our exploit string and manually instantiate our class. The problem only comes when we put all of these things together.</p><h2>The Exploit</h2><p>We know we have a class that runs arbitrary code:</p><pre><code>unsafe_object = ActionDispatch::Routing::RouteSet::NamedRouteCollection.new
struct        = OpenStruct.new(defaults: {})
unsafe_object["foo; eval(puts '=== hello there'.inspect);"] = struct
# =&gt; "=== hello there"
</code></pre><p>And we know we can build objects like this using YAML:</p><pre><code>--- !ruby/hash:ActionDispatch::Routing::RouteSet::NamedRouteCollection
 'foo; eval(eval(puts '=== hello there'.inspect);': !ruby/object:OpenStruct
   table:
    :defaults: {}
</code></pre><p>Even with both of these elements our Rails app is still safe, unless users are allowed to send the application arbitrary YAML that gets loaded. As you’ve likely guessed, there was a bug that allowed a malicious user to use an XML request to inject YAML into a Rails app. When you put the three elements together, you have a system that can be completely taken over by a malicious user. If someone can run arbitrary code on your server, you don’t own that server anymore, they do.</p><h2>Hindsite 20/20</h2><p>The holes in Rails XML and JSON parsers for different vulnerable versions have been fixed, and some have asked why they weren’t detected and patched earlier. The simple answer is: security is hard. These issues are only obvious in retrospect. Rails and Ruby aren’t any less secure than other frameworks and languages. Security vulnerabilities are bugs at their core, and very difficult to detect. There is almost guaranteed to be insecure software on your laptop/phone/server/garage-door-opener somewhere – it just hasn’t been discovered yet.</p><p>Hopefully you’ve gotten a taste for how difficult it can be to spot these vulnerabilities. We can arm ourselves with knowledge and a healthy distrust for user submitted information.</p><h2>Knowledge is Power</h2><p>The more people who understand how YAML can be used against a system, the easier it will be to detect a security hole before it’s put in production. When vulnerabilities are discovered, it is important that developers around that software understand the root causes and help spread knowledge to others. I’m not a security researcher or specialist, but just a guy who’s been writing Rails code for a few years. Until I started researching this attack, I didn’t know why, but now I’ll never forget.</p><h2>Never Trust Your Users</h2><p>The lesson isn’t that YAML is evil, it’s still as awesome as it ever was. The lesson is that you should never trust your user’s input. If an attacker can’t touch your code or use it in unexpected ways, they can’t exploit it. This is hard to do in practice, but a little extra attention can go a long way.</p><h2>Stay Up to Date</h2><p>Subscribe to mailing lists or groups that post security announcements for the major pieces of software you use such as the the <a href="http://web.archive.org/web/20130210084912/https://groups.google.com/forum/?fromgroups#!forum/rubyonrails-security">Rails Security group</a>. When an announcement goes out, upgrade immediately even if the threat is small. Hopefully you’ve seen how one unexpected use of a software can lead to another. The company I work for, Heroku, considered the threat from this issue so severe that we notified the people who are running vulnerable code.</p><p>Even with all the knowledge in the world, it doesn’t do you any good if you continue to run software with known exploits.</p><h2>Recap</h2><p>You might not be a security researcher, but hopefully you’ve learned a thing or two not only about this YAML attack, but also the nature of a security exploit. You’ve learned to distrust user input, and you’ve learned that knowledge is power. So go share your knowledge by sending this article out to another developer, they might appreciate it.</p> <span id="pty_trigger"></span>
